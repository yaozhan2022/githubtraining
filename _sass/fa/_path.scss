/* FONT PATH
 * -------------------------- */

@font-face {
  font-family: 'FontAwesome';
  src: url('#{$fa-font-path}/fontawesome-webfont.eot?v=#{$fa-version}');
  src: url('#{$fa-font-path}/fontawesome-webfont.eot?#iefix&v=#{$fa-version}') format('embedded-opentype'),
    url('#{$fa-font-path}/fontawesome-webfont.woff?v=#{$fa-version}') format('woff'),
    url('#{$fa-font-path}/fontawesome-webfont.ttf?v=#{$fa-version}') format('truetype'),
    url('#{$fa-font-path}/fontawesome-webfont.svg?v=#{$fa-version}#fontawesomeregular') format('svg');
  //src: url('#{$fa-font-path}/FontAwesome.otf') format('opentype'); // used when developing fonts
  font-weight: normal;
  font-style: normal;
}

import sys
print(sys.version)
#pip install --user upgrade scanpy
#pip install singlecellexperiment singler
#pip install harmonypy
import datetime
import glob
import gzip
import json
import os
import pickle
import random
import re
import requests
import shutil
import subprocess
import textwrap
import urllib
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import anndata
#import gseapy as gp
#from gseapy.plot import gseaplot
import matplotlib as mpl
import matplotlib.pyplot as plt
import natsort
import numpy as np
import pandas as pd
import PIL
import scanpy as sc
import scipy
import scipy.stats as stats
sc.set_figure_params(dpi_save=450, format='png')
# import scrublet as scr
import seaborn as sns
import statsmodels.stats.multitest as multitest
#import singlecellexperiment as sce
#import singler
import scanpy.external as scex

%matplotlib inline

outdir = os.path.realpath('./pythonoutput/scqc')
if not os.path.exists(outdir):
    os.makedirs(outdir)
    
ad = None
fns = glob.glob('/mnt/efs/home/qyj3469/Data/pd_scRNA_nk_anno/TAK007_scRNA_Batch2/batch2_H5andHTML/*h5')
meta = pd.read_excel('/mnt/efs/home/qyj3469/Data/pd_scRNA_nk_anno/TAK007_scRNA_Batch2/TAK007_Batch2_scRNAseq_Final.xlsx',sheet_name=0,header=1)
meta = meta.iloc[:,1:5]
meta = meta.rename(columns={'Library ID#':'sample','Donor #':'donor'})

sparse=True
obj = []
for fn in fns:
    ad = sc.read_10x_h5(fn)
    ad.var_names_make_unique()
    sc.pp.filter_cells(ad, min_genes=200)
    sc.pp.filter_genes(ad, min_cells=3)
    sc.pp.filter_cells(ad, max_genes=6000)
    ad.var['mt'] = ad.var_names.str.startswith('MT-') 
    sc.pp.calculate_qc_metrics(ad, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
    ad = ad[ad.obs.pct_counts_mt < 20, :]
    key = os.path.split(fn)[1].replace('_filtered_feature_bc_matrix.h5','').replace('run_count_','')
    ad.obs['sample'] = key
    ad.obs.index += key
    obj.append(ad)
fig,axs = plt.subplots(1, 3, figsize=(10, 3))
    
ax = axs[0]
col = 'n_genes'
ad.obs[col].hist(ax=ax, bins=100)
ax.set_xlabel(col)
ax.set_ylabel('Number of cells')
ymin,ymax = ax.get_ylim()
#ax.vlines(4000, ymin, ymax, color='red')
ax.set_ylim(ymin, ymax)

ax = axs[1]
col = 'total_counts'
ad.obs[col].hist(ax=ax, bins=100)#bins=np.linspace(0, total_counts_max, 100))
ax.set_xlabel(col)
ax.set_ylabel('Number of cells')
ymin,ymax = ax.get_ylim()
#ax.vlines(1000, ymin, ymax, color='red')
#ax.vlines(10000, ymin, ymax, color='red')
ax.set_ylim(ymin, ymax)

ax = axs[2]
col = 'pct_counts_mt'
ad.obs[col].hist(ax=ax, bins=100)#np.arange(0, pct_mt_max + 1, 1))
ax.set_xlabel(col)
ax.set_ylabel('Number of cells')
ymin,ymax = ax.get_ylim()
#ax.vlines(10, ymin, ymax, color='red')
ax.set_ylim(ymin, ymax)

plt.tight_layout()
# plt.savefig(os.path.join(outdir, 'qc_hists_after_filtering.png'), dpi=600)

ad = sc.concat(obj,join='outer',axis=0)
sc.pp.filter_genes(ad, min_cells=3)
ad.var['mt'] = ad.var_names.str.startswith('MT-') 
sc.pp.calculate_qc_metrics(ad, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
ad.var['gene_id'] = ad.var_names
viral = ["iCas9_Vector","CD19CAR","IL15_Vector","5LTR_Vector","3LTR_Vector","AmpR_Vector"]
ad.var['viral'] = ad.var_names.isin(viral) 
sc.pp.calculate_qc_metrics(ad, qc_vars=['viral'], percent_top=None, log1p=False, inplace=True)
ad.var.head()

import gc 
gc.collect()
import ctypes
libc = ctypes.CDLL("libc.so.6")
libc.malloc_trim(0)

ad.obs = ad.obs.merge(meta, how="left").set_axis(ad.obs.index)
ad.obs['sample'].value_counts().head()
ad.obs['Day'].value_counts().head()

REPLACE = False
out_fn = os.path.join(outdir, 'B2007_filtered.h5ad')

if not os.path.exists(out_fn) or REPLACE:
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sc.read_h5ad(out_fn)

out_fn = os.path.join(outdir, 'B2007_filtered_norm.h5ad')
if not os.path.exists(out_fn) or REPLACE:
    sc.pp.normalize_total(ad, target_sum=1e4)
    sc.pp.log1p(ad)
    fn = 'https://raw.githubusercontent.com/theislab/scanpy_usage/master/180209_cell_cycle/data/regev_lab_cell_cycle_genes.txt'
    cell_cycle_genes = list(pd.read_table(fn, header=None, squeeze=True))
    
    # Split into 2 lists
    s_genes = [x for x in cell_cycle_genes[:43] if x in ad.var['gene_id'].values]
    g2m_genes = [x for x in cell_cycle_genes[43:] if x in ad.var['gene_id'].values]
    s_genes = list(ad.var[ad.var['gene_id'].isin(s_genes)].index)
    g2m_genes = list(ad.var[ad.var['gene_id'].isin(g2m_genes)].index)
    
    temp = sc.pp.scale(ad, copy=True)
    sc.tl.score_genes_cell_cycle(temp, s_genes=s_genes, g2m_genes=g2m_genes)
    ad.obs = ad.obs.join(temp.obs[['S_score', 'G2M_score', 'phase']])
    ad.obs['phase'] = pd.Categorical(ad.obs['phase'], ['G1', 'S', 'G2M'])
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sc.read_h5ad(out_fn)

ad.obs['phase'].value_counts()
sc.pp.highly_variable_genes(ad, min_mean=0.0125, max_mean=3, min_disp=0.5)
ad.var['highly_variable'].value_counts()
sc.pl.highly_variable_genes(ad)

aname='fil_normed'
out_fn = os.path.join(outdir, '{}_clustering.h5ad'.format(aname))
if not os.path.exists(out_fn) or REPLACE:
    # Scale data to unit variance and zero mean (for PCA)
    sc.pp.scale(ad, max_value=10)
    sc.tl.pca(ad,svd_solver='arpack')
    scex.pp.harmony_integrate(ad, 'sample')
    sc.pp.neighbors(ad, n_pcs = 50, use_rep = 'X_pca_harmony')
    sc.tl.umap(ad)
    sc.tl.leiden(ad, resolution=0.5)
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sc.read_h5ad(out_fn)

color = ['phase', 'total_counts', 'pct_counts_mt', 'donor', 'Day', 'CAR_UTD']
sc.pl.pca(
    ad, 
    gene_symbols='gene_id', 
    color=color, 
    ncols=6,
    wspace=0.5,
)

color = ['leiden', #'phase', 'pct_counts_mt', 
         'donor', 'Day', 'CAR_UTD']
sc.pl.umap(
    ad, 
    color=color,
    gene_symbols='gene_id',
    #save=out_stub,
    ncols=4,
    wspace=0.5,
)

import gc 
gc.collect()
import ctypes
libc = ctypes.CDLL("libc.so.6")
libc.malloc_trim(0)

out_fn = os.path.join(outdir, 'B2007_filtered_norm.h5ad')
if not os.path.exists(out_fn) or REPLACE:
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sce.read_h5ad(out_fn)
    mat = ad.assay("X")
    features = [str(x) for x in ad.row_data["gene_id"]]

# single_results = singler.annotate_single(
#     mat,
#     features,
#     ref_data = "MonacoImmune",
#     ref_features= "symbol",
#     ref_labels = "main",
#     cache_dir = "_cache",
#     num_threads = 6
# )
# label = pd.DataFrame(single_results.column('best'))
# label.value_counts()

single_results.dice = singler.annotate_single(
    mat,
    features,
    ref_data = "DatabaseImmuneCellExpression",
    ref_features= "symbol",
    ref_labels = "main",
    cache_dir = "_cache",
    num_threads = 6
)
label_dice = pd.DataFrame(single_results.dice.column('best')).to_csv(os.path.join(outdir, "DICE.csv" ), sep = "\t")
pd.DataFrame(single_results.dice.column('best')).value_counts()

color = ['leiden', 'DICE','Day']
out_stub = '_{}_'.format(aname) + '_'.join(color) + '.png'
sc.pl.umap(
    ad, 
    color=color,
    gene_symbols='gene_id',
    #save=out_stub,
    ncols=3,
    wspace=0.5,
)
# move_scanpy_plot(out_stub, outdir)

ad.obs['CAR+'] = np.where(ad.obs.total_counts_viral > 0, 'CAR+','CAR-')
ad.obs['CAR+'].value_counts()
ad.obs['day_car'] = ad.obs['Day'].astype(str) + '_' + ad.obs['CAR_UTD'].astype(str)

aname='fil_normed'
out_fn = os.path.join(outdir, '{}_clustering.h5ad'.format(aname))
if not os.path.exists(out_fn) or REPLACE:
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sc.read_h5ad(out_fn)
    ad.obs['DICE']=pd.DataFrame(single_results.dice.column('best')).to_numpy()
    ad.write_h5ad(out_fn, compression='gzip')
pd.DataFrame(ad.obsm['X_umap']).to_csv(os.path.join(outdir,'umap.csv'))
pd.DataFrame(ad.obs).to_csv(os.path.join(outdir,'obs.csv'))

#uMAP of each of DICE sub population markers
## markers from Seurat tutorial canonical markers
#  Markers	Cell  Type
#0	IL7R, CCR7	  Naive CD4+ T
#1	CD14, LYZ	    CD14+ Mono
#2	IL7R, S100A4	Memory CD4+
#3	MS4A1	        B
#4	CD8A	        CD8+ T
#5	FCGR3A, MS4A7	FCGR3A+ Mono
#6	GNLY, NKG7	  NK
#7	FCER1A, CST3	DC
#8	PPBP	        Platelet
color = ['CD4','CD8A','IL7R','CCR7','MS4A1','CD19','GNLY','NKG7']
sc.pl.umap(
    ad, 
    color=color,
    gene_symbols='gene_id',
    ncols=4,
    wspace=0.5,
)

color = ['GZMK','SELL','CMC1','IFRD1',#'PIK3R1',#transitional
           'ZFP36','JUNB',#'IER2',#active 
           'PRF1','GZMA',#'GZMB','FCGR3A',#mature
           'WDR74','SNORD3A',#terminal
           'KLRC2','S100A6',#adaptive
           'PMAIP1','TNF']
sc.pl.umap(
    ad, 
    color=color,
    gene_symbols='gene_id',
    ncols=4,
    wspace=0.5,
)

aname='fil_normed'
out_fn = os.path.join(outdir, '{}_clustering.h5ad'.format(aname))
if not os.path.exists(out_fn) or REPLACE:
    ad.write_h5ad(out_fn, compression='gzip')
else:
    ad = sc.read_h5ad(out_fn)
marker_genes_dict = {
    'B-cell': ['CD79A', 'MS4A1'],
    'Dendritic': ['FCER1A', 'CST3'],
    'Monocytes': ['FCGR3A'],
    'NK': ['GNLY', 'NKG7'],
    'Other': ['IGLL1'],
    #'Plasma': ['IGJ'],
    'T-cell': ['CD3D'],
}
sc.pl.dotplot(ad, marker_genes_dict, 'leiden', dendrogram=True)

sc.pl.matrixplot(ad, marker_genes_dict, 'leiden', dendrogram=True, cmap='Blues', standard_scale='var', colorbar_title='column scaled\nexpression')

ax = sc.pl.tracksplot(ad, marker_genes_dict, groupby='leiden', dendrogram=True)

#ad.uns['log1p']["base"] = None
sc.tl.rank_genes_groups(ad, groupby='leiden', method='wilcoxon')
sc.pl.rank_genes_groups_dotplot(ad, n_genes=4)
sc.pl.rank_genes_groups_heatmap(ad, n_genes=10, use_raw=False, swap_axes=True, show_gene_labels=False,
                                vmin=-3, vmax=3, cmap='bwr')












































































